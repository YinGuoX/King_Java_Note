# Redis进阶

- 主要参考自：https://www.bilibili.com/video/BV1Rv41177Af?p=27&spm_id_from=pageDriver

# 1. 秒杀案例-库存遗留问题

- 为什么会产生库存遗留问题？
  - Redis乐观锁产生的问题：watch+multi
  - 同一时刻2000人进行了秒杀，其中有一个人抢到了这个商品，并且修改了这个版本号，会导致剩下的人版本号都不匹配导致抢不到商品，从而导致就算商品还有，但是剩下的人也不能做任何操作从而抢不到商品，导致库存遗留问题
- 如何解决库存遗留问题？
  - Lua脚本语言：是一种小巧的脚本语言，可以很容易被C/C++调用，也可以反过来调用C/C++函数，整个解释器不过才200k，一般作为嵌入式脚本语言使用
  - Lua在Redis中的优势？
    - Lua脚本是类似redis事务，具有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作，在redis2.6以上版本才可以使用
  - 通过Lua脚本解决争抢问题实际上是**Redis利用其单线程的特性，使用任务队列的方式解决多任务并发问题**

# 2. Redis应用问题

- 缓冲穿透：
  - ![image-20220308144642096](3_Redis%E8%BF%9B%E9%98%B6.assets/image-20220308144642096.png)
  - 如何解决？
    - 对空值进行缓存
    - 设置可访问的名单（白名单）
    - 采用布隆过滤器
    - 进行实时监控
- 缓存击穿：
  - ![image-20220308143035091](3_Redis%E8%BF%9B%E9%98%B6.assets/image-20220308143035091.png)
  - 如何解决？
    - 预先设置热门数据到redis中，并且加大key的过期时间
    - 实时调整，加大key的过期时间
    - 使用锁
- 缓存雪崩：
  - ![image-20220308143351748](3_Redis%E8%BF%9B%E9%98%B6.assets/image-20220308143351748.png)
  - 如何解决：
    - 多级缓存结构：nginx缓存+redis缓存+其他缓存
    - 使用锁或者队列
    - 设置过期标志，更新缓存
      - 记录缓存数据是否过期，如果过期会触发通知其他线程在后台去更新实际key的缓存
    - 将缓存失效时间分散开
      - 在原有的失效时间基础上增加一个随机值

# 3. 分布式锁

- 面临的问题：
  - 原本单体单机部署的系统演变成了分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同的机器上，这将使得原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。
  - 为了解决这个问题机需要一种跨JVM的互斥访问机制来控制共享资源的访问，这就是分布式锁要解决的问题
- 分布式锁的主流方案：
  - 基于数据库实现分布式锁
  - 基于缓存=》性能更高
  - 基于Zookeeper=》可靠性更高
- 使用Redis实现分布式锁：
  - redis命令：
  - setex key second value
  - set key value PX millisecond
  - set key value nx == setnx key value
- 具体实现1：
  - 使用setnx上锁，通过del释放锁
  - 锁一直没有释放，可能会产生死锁，可以设置key过期时间，自动释放
  - 以上需要原子性操作！！！不然也会产生死锁：
    - 上锁的时候设置过期时间：set users 10 nx ex 15;
- 实现1带来的问题：
  - 线程的锁可以被其他线程释放！
  - ![image-20220308151507122](3_Redis%E8%BF%9B%E9%98%B6.assets/image-20220308151507122.png)
- 具体实现2：UUID防止误删
  - 线程在上锁时带上自己的唯一标识，可以设置在锁的value中
  - 在释放锁时，可以判断是否相等来释放自己的锁
- 实现2带来的问题：
  - 删除操作不是原子性的，还是可以导致线程的锁被其他线程释放
  - ![image-20220308152853863](3_Redis%E8%BF%9B%E9%98%B6.assets/image-20220308152853863.png)
- 具体实现3：Lua脚本实现删除原子性
- 分布式锁可用的四个条件：
  - 互斥性：任意时刻，只能有一个客户端能够持有锁
  - 不会发生死锁：
    - 即使有一个客户端在持有锁时奔溃而没有主动释放锁，也可以保证后续其他客户能够加锁
  - 解铃还需系铃人：加锁和解锁必须是同一个客户端
  - 加锁和解锁必须是原子性操作

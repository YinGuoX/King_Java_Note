# 腾讯面试问答

# 1. 2022.3.6-提前一天抱佛脚-确实很难抱！

- 主要参考自：https://www.nowcoder.com/discuss/705347?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2
- 数组和链表的区别？
  - 数组：开辟一块连续的内存空间，可以使用下标就行快速访问任意元素，但是删除某个元素可能需要移动数组，较为麻烦
  - 链表：内存中离散存储，通过指针相互指向构成，增加删除可以方便实现，查找某个元素比较麻烦，可以使用跳跃表来改进
  - 当数组内存过大时会出现什么问题：JVM 堆内存溢出
  - 链表增删过多会出现的什么问题：大量内存碎片 
- 排序算法，稳定的算法，快排什么时候最坏（选定的值是最大，最小值），冒泡什么时候最好（有序） 
- jvm内存划分，堆和栈的区别 
  - 线程私有：程序计数器，本地方法栈，虚拟机栈
  - 线程共享：堆，方法区（永久代，元空间）
- 通信方式（tcp，udp） 
- io模型：
  - 两阶段来划分！
  - 阻塞IO模型
  - 非阻塞IO模型
  - IO多路复用模型
  - 信号驱动IO模型
  - 异步IO模型
- 堆内存分代划分和为什么要这么划分，优点
  - 方便垃圾回收！
  - 对象的存活时间不同
  - 垃圾收集算法的不同选择
- 快排和选择排序对方给了个例子问我第一次和第二次排序后会变成什么样子？
  - 不稳定！
  - 直接选择排序，不断找第i大的
  - 快排：找左边比pivot大的，找右边比pivot小的，一次迭代肯定可以找到pivot的最终位置
- 为什么选择排序是不稳定的：
  - 因为是不断找第i大的，举例相同值是如何排序的即可
- io模型和select，poll，epoll介绍以及为什么poll为什么从1024变成了65535
  - 系统最大的文件描述符数量：65535
  - Select:监听一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。
    - 默认大小是1024，
    - 优点：使用广泛，几乎所有的系统都支持select，精确，时间单位是微妙
  - Poll:与select类似
    - 描述符数量更多，监听的类型也更多，描述符的重复利用也比select高
  - select poll速度都比较慢，每次调用都要将全部的描述符从应用进程缓存区复制到内核缓冲区
  - Epoll:
    - epoll_ctl()：向内核注册新的描述符，或者修改描述符的状态，在内核中用红黑树维护
    - epoll_wait()：通过回调函数，内核将IO就续的描述符加入到链表进行管理，用户进程调用epoll_wait()就可以得到事件完成的描述符
    - epoll只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且有了回调函数，进程不需要通过轮询来获取事件完成的描述符
  - 三个对比：
    - select和poll采用轮询的方式，即每次都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此他们检测就绪事件的时间复杂度为O(n)，epoll_wait采用回调的方式，内核检测到就绪文件描述符时，将触发回调函数，回调函数将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当时机将该就绪事件队列中的内容拷贝到用户空间。
    - epoll比select、poll更加灵活，并且没有描述符的数量限制
    - epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。
- 你常用的设计模式，单例模式有什么用
  - 创建型：单例模式，建造者模式，
  - 行为型：模版方法模式
- TCP协议如何保证可靠传输
  - 三次握手
  - 数据传输：
    - 差错控制：CRC校验码
    - 确认机制、超时重传
    - 重复数据：ARQ协议：数据发送可靠
    - 流量控制：滑动窗口
    - 拥塞控制：拥塞控制
  - 四次挥手
- 对IO多路复用的理解 
- epoll和poll相比的，前者缺点在哪 
- 当服务器要处理2万次请求时，用哪一种IO多路复用方式比较好？
  - 只需要运行在 Linux 平台上，有**大量的描述符需要同时轮询**，并且这些**连接最好是长连接**。就可以使用epoll，因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl()  进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。
  - 需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。
  - 需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll
- 对linux编程了解多少？如何查看linux的负载？ 
  - shell脚本？
  - top
- Java的反射机制有什么用？ 
  - 对象的创建，方法的调用等时机可以由程序员指定
  - 可以动态的创建对象，被视为动态语言的关键
- Spring的AOP和IOC是什么？ 
  - AOP：面向切面编程，能够将于具体业务无关，但是却为业务模块所共通调用的逻辑或者责任（事务，日志，权限等），用以减少代码冗余，降低模块的耦合，有利于未来的可拓展性和可维护性，Spring AOP基于动态代理实现的
  - IOC：Inverse of Control：一种设计思想，将原本在程序中手动创建对象的控制权交给Spring框架来管理，**IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。**
- 解释一下HashMap底层是如何实现的？ 
  - Node（hash,key,value,next）对象的数组
  - 对Node对象的增、删、改、查的组织和操作
- 简单的MySQL查询提问，让我手写一下MySQL语句（太久没有写，语法有点忘记了，但是有说思路） 
- 对算法是否有了解？简述一下各种树结构？
  - 二叉树？完全二叉树？二叉搜索树？平衡二叉树？红黑树？B树？B+树？
- 树结构在后台开发中有哪些实际应用？
  - 排序+查找 
  - HashMap、MySQL索引
- 是否了解后台开发的一些实际技术？
  - Spring Boot 
  - Spring Cloud Alibaba=>naocs feign  gateway
  - Nginx
  - docker
  - Elastic search
- 三道算法题，给了三十分钟，输入需要自己构造 
  - 合并两个有序链表，
  - 判断是否为二叉平衡树，
  - 有序数组中找到目标值为K的数据 (比如[-8,-6,-3,1,2,4,6,8,10],target=3。那么打印(-3,6),(1,2) 
- 可以讲讲二叉平衡树的插入删除过程吗(emm真不了解，就知道不平衡的话需要调整，怎么个调整法也不清楚) 
  - LL、RR、RL、LR
- 在项目中有使用过树的数据结构吗(有，现在公司的项目,人员查询用的github开源的双数组前缀树)，前缀树的搜索插入过程讲一下 
- 为什么mysql用B+树(balabala)，你刚才提到了页，那么一页是多大呢?(4KB,8KB?记不清了)
  - Innodb页大小确实是16kb，操作系统页的大小是4kb，所以数据库一次IO应该会读四个操作系统的页
- 索引的选择原则与使用原则，再讲讲索引的缺点? 
  - 复合索引，唯一索引，
  - 最佳左前缀原则，不要使用范围查找？函数？计算？类型转换？!=、null、or、%like
  - 如果是聚簇索引：数据的存放和索引位置一致，容易影响数据的增加和删除的性能
  - 如果是非聚簇索引：数据和索引存放在不同文件，浪费存储空间
- 慢查询如何优化? 
  - 使用explain!
  - Select_type?数据查询使用的什么操作？simple?primary?subquery
  - Type?使用的什么索引类型？sys>cons>ref>range>index>all
  - Keys?使用了哪些索引？
  - rows?查询了多少行？
  - extra？using file sort,using temporary, using index
- 如何保证数据库的高并发写入？(加缓存？加锁?)讲讲数据库有哪些锁
  - 确保一致性！
  - 表级锁、行级锁？读写锁？意向读写锁
  - innoDB：gap lock, next-key lock,MVCC 
- 数据库事务讲一下，以及如何保证原子性和持久性
  - RU
  - RC
  - RR
  - S
  - 原子性：undo log
  - 持久性：redo log 
- 用户态和内核态的区别(用户线程，内核线程，特权指令和非特权指令) 
- 系统调用和用户调用的区别，有哪些操作属于系统调用，为什么系统调用开销大 
  - 系统调用？mmap()? sendfile()? 
  - 为什么开销大？上下文切换！CPU中断
- TCP哪些机制保证了它可靠?它一定可靠吗?(一定) 
  - 建立连接
  - 数据传输：差错控制，数据校验，数据确认，超时重传，拥塞控制，流量控制
  - 关闭连接
- 解释下面向流和面向报文的区别，以及优缺点，还有解决方案(就是TCP沾包的解决方案) 
  - UDP：一次发送一个报文，太长IP要分片，太短又要保留边界，浪费资源
  - TCP：面向无结构的字节流，可以自己根据实际情况进行划分，划分成报文段发送出去，所以没有报文边界，容易导致沾包问题
  - 沾包问题：发送方发送了若干包数据，到接收方时沾成一包，容易得到错误的数据
  - **粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。**因此：
  - 明确边界，或者接收方能够得知发送包的大小
  - 为字节流添加上自定义的固定长度的报头，然后一次发送到接收方，接收方取出定长的报头，然后再读取真实数据
- 智力题:十二个形状相同的小球，有一个和其他十一个质量不同，一个天平，怎么快速找出(感觉分三堆是最好的，需要三次比较)

# 2. 3.7

- 稳定的排序算法？
  - 直接插入排序
  - 冒泡排序
  - 归并排序
  - 快排的三指针
- 不稳定的排序算法？
  - 直接选择排序
  - 希尔排序
  - 快排
  - 堆排序
- 快排是稳定的吗？
  - 三指针法似乎是稳定排序的！
- 进程间的通信方式？区别？哪些场景可以用到？
  - 低级通信：控制信息的交互：信号
  - 高级通信：大批数据的交互：管道、消息队列、共享内存、套接字
  - 管道：
    - 只能单向传输，并且也只能在父子进程间使用
    - 方便简单
    - 场景：只能给具有亲缘关系的进程间使用
  - 匿名管道
    - 单向传输，可以提供给任意关系的进程使用
    - 使用场景：允许无亲缘关系进程间的通信
  - 信号：
    - 由用户，系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或者系统异常（某些事件发生了）
    - 主要是触发某些行为，但是传递的信息少
  - 信号量：
    - 一种特殊的变量，本质还是计数器，记录了临界资源的数目。
    - 进程对信号量的访问都是原子操作（PV操作：P占用资源，V：释放资源），
    - 主要作用：协调进程对共享资源的访问，让临界区同一时间只有一个进程在访问，一种进程同步的手段，一般和共享内存配合使用
  - 消息队列：
    - 就是消息的链接表，存放在内核中，有足够权限的进程可以向队列中添加消息，被赋予读权限的进程可以读取队列中的消息
    - 允许任意进程通过共享消息队列来实现进程间的通信，并由系统调用函数来实现消息发送和接收之间的同步，从而使得用户在使用消息队列进行通信时不再考虑同步问题
    - 消息队列主要解决了信号传递信息少，管道又只能承载无格式字节流以及缓冲区大小等限制。UNIX允许不同进程将格式化数据流以消息队列的方式发送给任意进程。但是消息队列中的信息复制需要额外消耗CPU时间，不适宜信息量大或者操作频繁的场景
  - 共享内存：
    - 可以说是效率最高的一种通信方式，直接映射一段能被其他进程访问的内存
    - 使多个进程可以访问同一块内存空间直接进行信息的交换，主要是针对其他通信机制运行效率低设计的，一般和信号量结合使用，来达到进程间的同步和互斥
    - 共享内存无需复制，快捷，信息量大，但是只能由处于同一个计算机系统中的进程共享，不方便网络通信
  - 套接字：
    - 主要是针对网站，通信模型是客户端和服务器端之间的通信，两端都建立了Socket对象，进行数据传输
    - 一般用于不同计算机的不同进程间进行通信
- 进程和线程的区别？（分点！）
  - 单位上：进程是程序运行的基本单位，线程是独立调度的基本单位
  - 资源上：进程是系统分配资源的基本单位，同一类线程共享进程资源
  - 上下文切换上：同一类线程切换不会引起系统上下文的切换
  - 系统开销上：
  - 通信角度上：
- 为什么需要线程？
  - 进程带来的问题？
    - 虽然进程可以提高CPU的利用率，但是多个进程之间进行切换是十分耗费资源和时间的：上下文切换，保存现场数据等
  - 为了进一步提高系统的并发性，提高CPU的利用率，才提出的线程，一个进程可以创建多个线程，并且线程可以共享进程所分配到的资源，所以线程的创建、撤销、切换等所占用的资源比进程少的多。也就更好的提高系统并发性和CPU利用率
- 线程之间有哪些共享资源？存储共享？网络共享？
  - 可以参考：https://blog.csdn.net/weixin_44747933/article/details/111398906
  - 考虑线程间哪些资源是线程私有的！
    - 线程运行的本质就是函数的执行，函数的执行总会有一个源头，也就是入口函数，CP U从入口函数开始执行从而形成一个执行流
    - 那么函数执行都有哪些信息呢？类比JVM的栈帧
      - 函数的运行时信息保存在栈帧中，栈帧中保存：局部变量表、操作数栈、方法返回地址、以及函数使用的寄存器信息
    - CPU执行的指令信息保存在一个叫程序计数器的寄存器中，用来指定CPU下一条将要执行的指令
    - 线程的栈区、程序计数器、栈指针、函数运行使用的寄存器都是线程私有的（统一叫线程上下文）
  - 知道了哪些资源是线程私有的后，剩下的就是线程间共享的资源：
    - ![image-20220308102055152](3_%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94.assets/image-20220308102055152.png)
    - ![image-20220308102220209](3_%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94.assets/image-20220308102220209.png)
    - 代码区：
      - 保存的是编译后的可执行机器指令，机器指令由可执行文件加载到内存中
      - 线程之间共享代码区：程序的任何一个函数都可以放到线程中区执行，不存在某个函数只能特定线程执行的情况
    - 数据区：
      - 存放的是全局变量，函数之外的数据
      - 线程之间共享数据区：数据区中的全局变量有且仅有一个实例，所有线程都可以访问到该全局变量
    - 堆区：
      - malloc或者new 出来的数据存放的区域
      - 只要知道变量的地址，任何一个线程都可以访问该变量
      - 动态链接库：动态库也是共享的
    - 栈区：
      - 同一进程下的不同线程的栈区，没有严格隔离，知道了地址后，一个线程可以访问另一个线程的栈区，并且进行修改
- 计算机三大块？
  - 数据通信=》IO
  - 数据存储=》内存
  - 数据计算=》CPU
- 容器？Docker？介绍一下？
  - 之前的服务器的问题：
    - 几个服务又浪费，多个服务又容易互相影响，内存泄露啥的
  - 如何解决？虚拟机实现隔离=》需要装自己的操作系统核心，浪费资源
  - 目前：Docker：共享操作系统核心，占用资源少，启动速度快，并且能够给资源一定程度的隔离
  - 核心思想：集装箱+联合文件系统
- 虚拟机的弊端？隔离级别的区别？隔离了哪些东西？隔离的资源？Java在Docker上部署有哪些坑？
  - 虚拟机的弊端：虚拟出一套硬件，运行一个完整的操作系统，然后就在这个系统上安装和运行软件，体量大、冗余，
  - Docker：共用内核，只靠cgroup（控制组）+namespace隔离，应用之间的隔离是不如虚拟机彻底的，如果某个应用运行时导致内核崩溃，所有的容器都会崩溃。而虚拟机内的应用崩溃，理论上是不会影响其它虚拟机以及上面运行的应用的，除非是硬件或者Hypervisor有Bug。
- 有学习过K8S？
- 协程？
  - 一种比线程更加轻量级的存在，一个线程可以拥有多个协程，协程不是由操作系统内核管理，而是完全在用户态执行！完全由程序控制
  - coroutine 是从另一个方向演化而来，它是对 continuation 概念的简化。Lua 设计者反复提到，coroutine is one-shot semi-continuation。PiL 中给出了 iterator 例子，就是 continuation 如何可以把本来的多次回调变成一个连续的过程。理解了 continuation 也就理解了 coroutine。
    - 一组序列化的子过程，用户可以进行调度执行
    - 是一串比函数粒度还小的可手动控制的过程
- TCP三次握手？
- HTTP协议？版本迭代过程？
  - HTTP1.0
  - HTTP1.1
  - HTTP2.0
- MySQL 的 InnoDB的索引的结构？B+树？详细说B+树的构成？每个叶子结点里面怎么进行查找？
  - B+树节点：保存Key(主键)和指针
  - B+树构成：
- MySQL事务？隔离级别？不可重复读？幻读？间隙锁的缺点？临建锁？
- java和python的对比？Java不可以开多进程？
- Java的并发控制相关？AQS怎么实现的？信号量？CountDownLunch?
- 兴趣爱好？
- 反问？
  - 部门是做什么的？
  - 新人制度？
  - 再复习一下操作系统和计算机网络
- 总结：
  - 问答逻辑清晰：是什么？为什么？构成？目的？实现？
  - 反问？
    - 你要做什么？=》部门？
    - 你将要做什么？=>有什么不足，哪里还需要改进？
    - 作为前辈，从事计算机行业有什么感触（看机会聊？高情商？）


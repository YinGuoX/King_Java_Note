# 动态规划理解

- 主要参考：https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html

## 1. 动态规划是什么？

- 动态规划：Dynamic Programming : DP
- 如何判断是否使用DP：
  - 如果某一个问题有很多个重叠子问题，那么使用动态规划是最有效的
    - 严格定义：最优子结构、重叠子问题！
  - 所以动态规划中每一个状态可以由上一个状态推导出来的，
    - 此时区别与贪心：贪心无状态推导，而是局部最优
- 如何使用DP，如何分析？
  - 确定dp数组，以及下标含义！=定义dp数组
  - 确定递推公式
  - dp数组初始化
  - 确定遍历顺序
  - 举例推导dp数组
- 如何debug？
  - 打印dp数组，判断是否与预期相同，模拟真实结果
- DP总结：
  - 01背包问题：取还是不取是个问题！
    - 什么是重量？什么是价值？
    - dp是最大价值还是总数量？=>max or Add
  - 完全背包问题：取还是不取、取多少是个问题！
    - 滚动数组的必要性
      - 背包从小到大重复
      - 背包从大到小01背包！
    - dp是最大价值？dp[j] = max(dp[j],dp[j-weight[i]]+values[i])
    - dp是总数量？dp[j]+=dp[j-weight[i]]
      - 物品=>背包=>组合数
      - 背包=>物品=>排列数
    - dp是最小数量？dp[j] = min(dp[j],dp[j-weights[i]]+1)
      - 物品=>背包=>组合数
      - 背包=>物品=>排列数
  - 打劫问题：一般打劫、环形打劫、树形打劫
  - 股票问题：dp[i][j]：i为天，j为状态
    - 只能买卖一次、
    - 买卖多次、
    - 最多买卖2、k次
    - 买卖多次+冷冻期
    - 买卖多次+手续费
  - 子序列问题(数量、大小问题)：dp[i][j]，0-i-1字符串1，0-j-1字符串2，考虑w1[i-1]!=w2[j-1]时候的状态变化！
    - 不连续：最长上升、最长公共
    - 连续：最长上升、最长公共、最大连续和
    - 编辑距离：是否子序列、多少不同子序列、两个字符串的删除相等、编辑距离
    - 回文：子串个数、最长回文子序列

## 2. 入门实例

> - 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。
> - leetcode:https://leetcode-cn.com/problems/fibonacci-number/submissions/

- 分析：
  - 定义dp数组以及下标含义：
    - dp[i]：定义为：第i个数的斐波那契数列的数值=dp[i]
  - 确定递推公式：
    - 如题，可以知道：dp[i]=dp[i-1]+dp[i-2]
  - dp数组初始化：
    - 如题：dp[0]=0,dp[1]=1
  - 确定遍历顺序：
    - 从递推公式dp[i]=dp[i-1]+dp[i-2]可以得出，dp[i]取决于dp[i-1]和dp[i-2]，因此遍历顺序一定是从前往后的
  - 举例推导dp数组：推导i=10时是否能够正确推导出来，代码实现和结果对照

---

> - 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
>   
>   每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>   
>   注意：给定 n 是一个正整数。
> 
> - leetcode:https://leetcode-cn.com/problems/climbing-stairs/

- 分析：
  - 定义dp数组：
    - dp[i]定义为：爬到i阶楼梯有dp[i]种方法
  - 确定递推公式：
    - 如dp[i]的定义，dp[i]可以从两个方向推导出来：**加法原理**！！！
      - dp[i-1]，上到i-1阶楼梯，有dp[i-1]种方法，那么再跳一阶就是dp[i]，
      - dp[i-2]，上到i-3阶楼梯，有dp[i-2]种方法，那么再跳两阶就是dp[i]
    - 所以dp[i]一共有这两种可能：
      - dp[i]=dp[i-1]+dp[i-2]
    - **在推导dp[i]的时候，要牢记dp[i]的定义！！！**
  - 确定dp的初始化
    - 因为n是正整数，因此可以不考虑dp[0]，当然为了结果推导也可以赋值
    - 根据题目，dp[1]=1,dp[2]=2
  - 确定遍历顺序：
    - 从递推公式dp[i]=dp[i-1]+dp[i-2]可以得知，遍历顺序一定是从前往后的！
  - 举例推导dp数组：当n为5时，dp数组应该为：
    - 1 2 3 5 8

---

> - 数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
> - 示例 1：输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
> - 提示：
> - cost 的长度范围是 [2, 1000]。
>   - cost[i] 将会是一个整型数据，范围为 [0, 999] 
> - leetcode：https://leetcode-cn.com/problems/min-cost-climbing-stairs/

- 分析：
  - 确定dp数组以及下标含义：
    - dp[i]定义为：达到第i个台阶所花费的最少体力为dp[i]
  - 确定递推公式：
    - 根据题目含义和dp[i]的定义
    - 应该判断如何选择dp[i-1]、dp[i-2]
    - 由于dp[i]表示的是最少的体力，所以dp[i]=min(dp[i-1],dp[i-2])+cost[i];
      - 思考为什么是cost[i]？
        - 因为如果要继续往上爬，就需要支付第i台阶的体力
        - 此时考虑题目实例：发现第一步并没有计算代价，但是按我们的定义，需要计算第一步的代价，根据举例推导dp可以发现：如果第一步需要计算代价的话，最后一步不支付即可获取正确答案！
  - 初始化dp数组
    - 根据dp数组的定义，发现初始化所有的dp[i]是不可能的，所以只能初始化dp[0]、dp[1]
    - 所以可以初始化：dp[0]=cost[0];dp[1]=cost[1]
  - 确定遍历顺序
    - 根据递推公式，可知是从前往后！
  - 举例推导dp数组：
    - cost = [10, 15, 20] 
    - 代入递推公式
    - dp=[10，15，15+20]，因为是最后一步，所以15+20-20即可

## 2. 进阶实例

> - leetcode:https://leetcode-cn.com/problems/unique-paths/
> 
> - 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
>   
>   机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>   
>   问总共有多少条不同的路径
> 
> - 示例：
>   
>   - 输入：m = 3, n = 7 输出：28
>   - 输入：m = 2, n = 3 输出：3

- 分析：
  - 确定dp数组以及下标含义
    - dp(i)(j)定义为：表示从0，0出发到(i,j)有dp(i)(j)条不同的路径
  - 确定递推公式
    - 想要求dpij只能从两个方向推导出来，即dp(i-1)(j)、dp(i)(j-1)
    - 此时重新回顾一下dp数组的定义
      - dp(i-1)(j)表示从0，0出发到(i-1,j)有dp(i-1)(j)条路径
      - dp(i)(j-1)表示从0，0出发到(i,j-1)有dp(i)(j-1)条路径
    - 所以可以推导出
      - dp(i)(j)=dp(i-1)(j)+dp(i)(j-1)
  - 确定初始化
    - 根据题意可以得知dp(i)(0)肯定都是1，因为从0,0到(i,0)的路径只有一条
    - 同理dp(0)(j)=1
  - 确定遍历顺序
    - 根据递推公式dp(i)(j)=dp(i-1)(j)+dp(i)(j-1)，可以得知dp(i)(j)都是从上方和左放推导出来的
    - 所以可以考虑从左到右一层层遍历即可确保dp(i-1)(j)和dp(i)(j-1)都有数值
  - 举例推导dp数组
    - m=2,n=3 输出3
    - dp数组即为：
    - 1 1 1
    - 1 2 3
    - dp(2)(3)=3

> - leetcode：https://leetcode-cn.com/problems/unique-paths-ii/
> 
> - 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>   
>   机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>   
>   现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
> 
> - 示例：
>   
>   - 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]，默认m=3,n=3
>   - 输出：2
>   - 解释： 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径

- 分析：
  
  - 确定dp数组以及下标含义
    
    - dp(i)(j)定义为：从0,0到i,j有dp(i)(j)条路径，如果i,j是障碍物，则从0,0到障碍物的路径只有0条
  
  - 确定递推公式
    
    - 根据题意可以得知：在没有障碍物的情况下
      - dp(i)(j)=dp(i-1)(j)+dp(i)(j-1)
    - 如果i,j是障碍物，那么dp(i)(j)=0
  
  - 确定初始化dp值
    
    - 如果整条路径没有障碍物，则dp(i)(0)=1,dp(0)(j)=1
    - 如果有，则是dp(i-r)(0)=1,dp(i-r+1)(0)=0；r,0存在障碍物
  
  - 确定遍历顺序
    
    - 根据递推公式，初始化需要小心，然后从左到右依次遍历即可
  
  - 举例推导dp数组
    
    - 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]，默认m=3,n=3
    
    - 输出2
    
    - dp数组为：
    
    - ```java
      1 1 1
      1 0 1
      1 1 2   
      ```

> - leetcode：https://leetcode-cn.com/problems/integer-break/
> 
> - 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
>   
>   示例 1: 输入: 2 输出: 1
>   
>   解释: 2 = 1 + 1, 1 × 1 = 1。
>   
>   示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。

- 分析：
  
  - 确定dp数组以及下标定义：
    
    - dp[i]定义为：拆分数字i，可以得到的最大乘积为dp[i]
  
  - 确定递推公式
    
    - 根据题目，思考dp[i]是如何计算得到的
    - **可以从1遍历到j，每次遍历都有**：两种方法获取到dp[i]
      - 第一种是j*(i-j)直接相乘=》将整数i拆分为j和i-j两部分
      - 第二种是j*dp[i-j]，相当于拆分i-j=》将整数i拆分为两个以上的部分
    - 思考：j需要拆分吗？
      - 因为j是从1开始遍历的，拆分j的情况在遍历j的过程中已经计算过了
    - 所以递推公式：dp[i]=max({dp[i]，(i-j)*j，dp[i-j]\*j})
    - 思考：为什么最大值里面还需要比较dp[i]？
      - 因为dp[i]是最大的，所以每次计算dp[i]，要从中取最大的！
  
  - dp的初始化
    
    - 根据题意，可以得知dp[0]、dp[1]是无意义的，所以只需要初始化dp[2]=1即可
  
  - 确定遍历顺序：
    
    - 查看递推公式：dp[i]=max(dp[i]，max((i-j)*j，dp[i-j]\*j))；
    - dp[i]需要依靠dp[i-j]的状态，所以遍历i一定是从前往后的，
    - 枚举j的时候是从1开始的，i是从3开始的，这样才可以遍历判断(i-j)*j,并且刚好可以根据dp[2]计算出dp[i-j]
  
  - 举例推导dp数组
    
    - n=10
    
    - ```java
      # 下标     2 3 4 5 6 7 8 9 10
      # dp 值   1 2 4 6 9 12 18 27 36
      ```

> - leetcode：https://leetcode-cn.com/problems/unique-binary-search-trees/
> 
> - 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
>   
>   示例:
>   
>   ![img](https://img-blog.csdnimg.cn/20210113161941835.png)

- 分析：
  - 确定dp数组以及下标i的定义
    - 举例找潜在规律
    - 来看看n为3的时候，有哪几种情况。
    - 当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）
    - 当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！
    - 当2位头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！
    - 发现到这里，其实我们就找到的重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。
    - dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
    - 元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
    - 元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
    - 元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
    - dp[i]定义为：1到i为节点组成的二叉搜索树的个数为dp[i]
  - 确定递推公式
    - 在上面的分析中，可以看出dp[i] = dp[i]+dp[以j为头节点左子树节点数量]*dp[以j为头结点右子树节点数量]
    - **j相当于头节点元素，从1遍历到i为止**
    - 递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
  - 确定初始化
    - dp[0]=1
      - 从定义上来讲，空节点也是一颗二叉树，也是一颗二叉搜索树，这是可以说得通的
      - 从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。所以初始化dp[0] = 1
  - 确定遍历顺序
    - 从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态
  - 举例推导dp数组
    - n=3
    - 0 1 2 3
    - 1 1 1+1 2+2+1
- 总结：
  - 这道题很难，如果要采用动态规划的思想来解决，需要举例、画图、分析才能得到递推关系、找到递推关系式

## 4. 0-1背包问题

> - 有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

- 直观的使用暴力法，每个物品其实只有两个状态：取或不取，可以使用回溯法搜索出所有的情况，此时时间复杂度(2^n)

- 需要改进：动态规划
  
  - 示例：背包最大重量为4。
  - 物品为：
  
  |     | 重量  | 价值  |
  | --- | --- | --- |
  | 物品0 | 1   | 15  |
  | 物品1 | 3   | 20  |
  | 物品2 | 4   | 30  |

- 分析：
  
  - 确定dp数组以及下标i的含义：
    - dp(i)(j)表示从下标为0到i的物品里面任意取，放入容量为j的背包，价值总和的最大值dp(i)(j)
  - 确定递推公式：
    - 回顾dp定义：从下标为0-i的物品里面顺便取，价值总和最大
    - 可以从两个方面推导出来dp(i)(j)
      - 不放物品i：此时dp(i)(j)可以由dp(i-1)(j)推出，其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。
      - 放物品i：此时dp(i)(j)可以由dp(i-1)(j-weight(i))推出，dp(i-1)(j-weight(i))为背包容量为背包容量为j-weight[i]的时候不放物品i的最大加载，所以此时dp(i)(j)=dp(i-1)(j-weight(i))+value[i]
    - 所以递推公式为：
      - dp(i)(j)=max(dp(i-1)(j),dp(i-1)(j-weight(i)+value(i)));
  - dp数组初始化
    - 要与dp数组的定义吻合，不如容易越来越混乱
    - 从dp定义出发，可以得知
      - dp(i)(0)=0
      - 我们知道递推公式为：dp(i)(j)=max(dp(i-1)(j),dp(i-1)(j-weight(i)+value(i)));
        - 所以i是由i-1推导出来的，那么i=0就一定要初始化
        - dp(0)(j)：表示存放编号为0的物体的时候，各个容量的背包所能存储的最大价值
          - 所以当j<weight[0]时，dp(0)(j)=0
          - j>=weight[0]时，dp(0)(j)=value[0]
  - 确定遍历顺序
    - 根据递推公式，需要遍历物品与背包总量
    - 那么先遍历物品还是先遍历背包重量呢？
      - 都可以，但是先遍历物品更好理解！
      - 根据递推公式：dp(i)(j)=max(dp(i-1)(j),dp(i-1)(j-weight(i)+value(i)))：可以看出，dp(I)(j)依赖于dp(i-1)(j)和dp(i-1)(j-weight(i))，都是在dp(i)(j)的左上角方向
  - 举例推导dp数组